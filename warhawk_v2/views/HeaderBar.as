import util.Observable;import mvc.Controller;import display.DispatchMovie2;import warhawk_v2.MessageBundle;import warhawk_v2.MessageCodes;import warhawk_v2.controllers.HeaderBarController;import warhawk_v2.views.AbstractWarhawkView;/***************************************************************************\*																			**  The Header Bar view for Warhawk Widget Version 2							**																			**  Peter Hastie - 18th February 2009										**																			**  AS2.0																	**																			**  - Draws Header Bar on screen when error message sent from model			**  - Implements Observer interface in order to subscribe to model events	**  - Changes text display when mode changes									**  - Animates when data is loading (progress bar)							**  - Sends click event to controller which will request mode change			**																			*\***************************************************************************/class warhawk_v2.views.HeaderBar extends AbstractWarhawkView{		private var headerClip:MovieClip;			// An empty MovieClip to hold the pieces of the header bar	private var currentDepth:Number;			// The depth within the headerClip	private var circleClip:DispatchMovie2;			// The target/circle clip in the header	private var loadingStrip:MovieClip;				// Strip that functions as progress bar	private var modeText:MovieClip;					// Text indicating the mode we're in (Leaderboard, Head2Head, MyStats)		private var textSlideInterval:Number;			// Stores intervalID for the text sliding animation				/***************\	* Constructor	*	\***************/	public function HeaderBar(m:Observable, c:Controller, target:MovieClip, depth:Number){				// Set up model and abstract using inherited methods		super(m,c);		trace('HeaderBar: Constructor');		// The calling class will deal with registering this view with the model				// Name this view		viewName = 'HeaderBar View';				// Draw the view on stage		drawView(target,depth);	}			/*******************\	* Public functions	*	\*******************/	public function update(o:Observable, infoObj:Object):Void{		trace('HeaderBar: update(): iterating infoObj...');		var messageBundle:MessageBundle = MessageBundle(infoObj); // Recast the infoObj for typesafety		for (var prop in messageBundle){			trace(' > prop:'+prop+', messageBundle[prop]:'+messageBundle[prop]);		}		// This is where we decide whether or not this message is for us		if (messageBundle.messageType == MessageCodes.DOWNLOAD_PROGRESS){			trace('HeaderBar: update(): Calling redrawProgressBar');			redrawProgressBar(messageBundle);		} else if(messageBundle.messageType == MessageCodes.MODE_CHANGE){			trace('HeaderBar: update(): Calling showModeChange');			showModeChange(messageBundle);		}	}			// Define our own default controller for this, don't want null	public function defaultController (model:Observable):Controller{		trace('HeaderBar: defaultController(): returning a HeaderBarController');		return new HeaderBarController(model);	}		/*******************\	* Private functions	*	\*******************/	private function drawView(container:MovieClip, depth:Number){		trace('HeaderBar: drawView()');		// Make an empty clip which will contain all the pieces of the header bar			// - The loader bar strip movie			// - The text display movie			// - The circle & target movie		headerClip = container.createEmptyMovieClip("header_container_mc",depth);		headerClip._x = 5;		headerClip._y = 5;		// Start filling in that empty clip		currentDepth = 1;		// First add the loader strip on the lowest level		loadingStrip = headerClip.attachMovie("LoadingStrip","loading_strip_mc",currentDepth++);		loadingStrip._x = 34.6;		loadingStrip._y = 9.3;		loadingStrip.gotoAndStop(1);		// Next the mode text		modeText = headerClip.attachMovie("ModeName","mode_name_mc",currentDepth++);		// Finally the circleClip on the top level;		circleClip = DispatchMovie2(headerClip.attachMovie("TargetCircle","target_circle_mc",currentDepth++));		// Register the controller to listen for the click event on the button		circleClip.addListener("click",getController());		// Position the modeText based on the circle width		modeText._x = circleClip._width -10;		modeText._y = 13;	}		private function redrawProgressBar(bundle:MessageBundle):Void{		trace('HeaderBar: redrawProgressBar(): progress at '+bundle.messageInfo);		// Set the loadingStrip to the appropriate frame		// There are 20 frames, 20 is completely loaded. Therefore, divide percent loaded by 5		var setFrame:Number = Math.floor(bundle.messageInfo/5);		loadingStrip.gotoAndStop(setFrame);		trace('HeaderBar: redrawProgressBar(): setFrame is '+setFrame);		trace('HeaderBar: redrawProgressBar(): loadingStrip._name ='+ loadingStrip._name+', currentFrame = '+loadingStrip._currentFrame); 	}		private function showModeChange(bundle:MessageBundle):Void{		trace('HeaderBar: showModeChange(): changing to '+bundle.messageInfo);		// Slide text out of mask		if (modeText.mode_text_mc._x >= 10){			textSlideInterval = setInterval(this,"slideTextOut",10,bundle.messageInfo);		}		// Change text to frame named in messageInfo		if (!textSlideInterval){			trace('HeaderBar: showModeChange(): changing text');			modeText.mode_text_mc.gotoAndStop(bundle.messageInfo);		}		if (modeText.mode_text_mc._x < 10){			textSlideInterval = setInterval(this,'slideTextIn',10,bundle.messageInfo);		}		// Slide back	}		private function slideTextOut(frameName:String):Void{		if (modeText.mode_text_mc._x >= (modeText.mode_text_mc._width + 10)*-1){			trace('HeaderBar: slideTextOut(): sliding left');			modeText.mode_text_mc._x = modeText.mode_text_mc._x -5		} else {			trace('HeaderBar: slideTextOut(): removing interval');			clearInterval(textSlideInterval);			textSlideInterval = setInterval(this,'slideTextIn',10,frameName); // Always pair with the reappearance		}	}		private function slideTextIn(frameName:String):Void{		if (modeText.mode_text_mc._x < 10){			trace('HeaderBar: slideTextIn(): sliding right');			modeText.mode_text_mc.gotoAndStop(frameName);			modeText.mode_text_mc._x = modeText.mode_text_mc._x +5;		} else {			trace('HeaderBar: slideTextIn(): removing interval');			clearInterval(textSlideInterval);		}	}}