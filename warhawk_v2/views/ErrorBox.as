import util.Observable;import mvc.Controller;import warhawk_v2.MessageBundle;import display.DispatchButton;import warhawk_v2.controllers.ErrorBoxController;import warhawk_v2.views.AbstractWarhawkView;import warhawk_v2.AnimationCentre;import warhawk_v2.MessageCodes;/***************************************************************************\*																			**  The Error boxes view for Warhawk Widget Version 2						**																			**  Peter Hastie - 18th February 2009										**																			**  AS2.0																	**																			**  - Draws error box on screen when error message sent from model			**  - Implements Observer interface in order to subscribe to model events	**																			*\***************************************************************************/class warhawk_v2.views.ErrorBox extends AbstractWarhawkView{		private var messageType:String; 			// The MessageCode	private var messageBody:String; 			// Any explanation codes that are passed in (errors like 404 represented as String)		private var layerNumber:Number; 			// The depth that was passed in. 	private var errorsClip:MovieClip;			// An empty MovieClip to hold the error boxes	//private var currentDepth:Number;			// The depth within the errorsClip	private var clipsList:Array;				// The number of errorboxes currently displayed in errorsClip. Length of this +1 is current depth				/***************\	* Constructor	*	\***************/	public function ErrorBox(m:Observable, c:Controller, target:MovieClip, depth:Number, ac:AnimationCentre){		// Set up model and abstract using inherited methods		super(m,c,ac);		trace('ErrorBox: Constructor');		// The calling class will deal with registering this view with the model				// Name this view		viewName = 'Errors View';				// Make a container clip to hold the error boxes that will be generated		layerNumber = depth;		errorsClip = target.createEmptyMovieClip("errorsClip_mc", layerNumber);		errorsClip._x = 10;		errorsClip._y = 150;		//currentDepth = 0;		clipsList = new Array();	}			/*******************\	* Public functions	*	\*******************/	public function update(o:Observable, infoObj:Object):Void{		trace('ErrorBox: update(): iterating infoObj...');		var messageBundle:MessageBundle = MessageBundle(infoObj); // Recase the infoObj for typesafety		for (var prop in messageBundle){			trace(' > prop:'+prop+', messageBundle[prop]:'+messageBundle[prop]);		}		// This is where we decide whether or not this message is for us		if (messageBundle.dispatchingFunction == 'errorDetected'){			// Make the error message human readable			var messageString:String = formatMessage(messageBundle.messageType, messageBundle.messageInfo);			// Show the error on screen			displayError(messageString);		} else if (messageBundle.messageType == MessageCodes.ANIMATION_COMPLETE){			trace('Errorbox: update(): received animation_complete');				  // Check if the sprite is one of ours				  for (var i:Number = 0; i < clipsList.length; i++){					  if (clipsList[i] == messageBundle.messageInfo){						  trace('Errorbox: update(): found a match! at position '+i);						  // Remove the clip						  removeError(MovieClip(messageBundle.messageInfo));						  break;					  }				  }		}	}			// Define our own default controller for this, don't want null	public function defaultController (model:Observable):Controller{		trace('ErrorBox: defaultController(): returning an ErrorBoxController');		return new ErrorBoxController(model);	}			public function removeError(messageBox:MovieClip):Void{		trace('ErrorBox: removeError()');		// Get the sprite		trace('ErrorBox: removeError(): removing '+messageBox._name);		if (messageBox._alpha > 0){			//faderInterval = setInterval(this,"fadeOut",10,messageBox)			animationCentre.addSubscriber(messageBox,"_alpha",0);		} else {			// Remove the clip from the clipsList			for (var i:Number = 0; i < clipsList.length; i++){				if (clipsList[i] == messageBox){					clipsList.splice(i,1);					break;				}			}			errorsClip.removeMovieClip(messageBox);		}	}			/*******************\	* Private functions	*	\*******************/	private function displayError(errorMessage:String):Void{		trace('ErrorBox: displayError(): errorMessage='+errorMessage);		//currentDepth++;		//var errorBox:MovieClip = errorsClip.attachMovie("problemAlert","error_"+currentDepth,currentDepth);		var errorBox:MovieClip = errorsClip.attachMovie("problemAlert","error_"+clipsList.length,errorsClip.getNextHighestDepth());		errorBox.message_txt.text = errorMessage;		// Add the close button to the box		// Create buttons in this		var closeBtn:DispatchButton = DispatchButton(errorBox.attachMovie("closeBox","close",1));		closeBtn._x = 150;		closeBtn._y = 95;		// Register the controller to listen for the click event on the button		closeBtn.addListener("click",getController());		// Add the errorBox to the clips list		clipsList.push(errorBox);	}		private function formatMessage(errorType:String, errorInfo:String):String{		trace('ErrorBox: formatMessage():');		return(errorType+':\n'+errorInfo);	}			}